diff --git a/node_modules/react-native/Libraries/Pressability/Pressability.js b/node_modules/react-native/Libraries/Pressability/Pressability.js
index 5c8f2b8..0627b52 100644
--- a/node_modules/react-native/Libraries/Pressability/Pressability.js
+++ b/node_modules/react-native/Libraries/Pressability/Pressability.js
@@ -8,10 +8,10 @@
  * @format
  */
 
-import {isHoverEnabled} from './HoverState';
+import { isHoverEnabled } from './HoverState';
 import invariant from 'invariant';
 import SoundManager from '../Components/Sound/SoundManager';
-import {normalizeRect, type RectOrSize} from '../StyleSheet/Rect';
+import { normalizeRect, type RectOrSize } from '../StyleSheet/Rect';
 import type {
   BlurEvent,
   FocusEvent,
@@ -19,13 +19,13 @@ import type {
   MouseEvent,
 } from '../Types/CoreEventTypes';
 import PressabilityPerformanceEventEmitter from './PressabilityPerformanceEventEmitter.js';
-import {type PressabilityTouchSignal as TouchSignal} from './PressabilityTypes.js';
+import { type PressabilityTouchSignal as TouchSignal } from './PressabilityTypes.js';
 import Platform from '../Utilities/Platform';
 import UIManager from '../ReactNative/UIManager';
-import type {HostComponent} from '../Renderer/shims/ReactNativeTypes';
+import type { HostComponent } from '../Renderer/shims/ReactNativeTypes';
 import * as React from 'react';
 import ReactNativeFeatureFlags from '../ReactNative/ReactNativeFeatureFlags';
-import {type PointerEvent} from '../Types/CoreEventTypes';
+import { type PointerEvent } from '../Types/CoreEventTypes';
 
 export type PressabilityConfig = $ReadOnly<{| 
   /**
@@ -34,140 +34,140 @@ export type PressabilityConfig = $ReadOnly<{|
    */
   cancelable?: ?boolean,
 
-  /**
-   * Whether to disable initialization of the press gesture.
-   */
-  disabled?: ?boolean,
-
-  /**
-   * Amount to extend the `VisualRect` by to create `HitRect`.
-   */
-  hitSlop?: ?RectOrSize,
-
-  /**
-   * Amount to extend the `HitRect` by to create `PressRect`.
-   */
-  pressRectOffset?: ?RectOrSize,
-
-  /**
-   * Whether to disable the systemm sound when `onPress` fires on Android.
-   **/
-  android_disableSound?: ?boolean,
-
-  /**
-   * Duration to wait after hover in before calling `onHoverIn`.
-   */
-  delayHoverIn?: ?number,
-
-  /**
-   * Duration to wait after hover out before calling `onHoverOut`.
-   */
-  delayHoverOut?: ?number,
-
-  /**
-   * Duration (in addition to `delayPressIn`) after which a press gesture is
-   * considered a long press gesture. Defaults to 500 (milliseconds).
-   */
-  delayLongPress?: ?number,
-
-  /**
-   * Duration to wait after press down before calling `onPressIn`.
-   */
-  delayPressIn?: ?number,
-
-  /**
-   * Duration to wait after letting up before calling `onPressOut`.
-   */
-  delayPressOut?: ?number,
-
-  /**
-   * Minimum duration to wait between calling `onPressIn` and `onPressOut`.
-   */
-  minPressDuration?: ?number,
-
-  /**
-   * Called after the element loses focus.
-   */
-  onBlur?: ?(event: BlurEvent) => mixed,
-
-  /**
-   * Called after the element is focused.
-   */
-  onFocus?: ?(event: FocusEvent) => mixed,
-
-  /**
-   * Called when the hover is activated to provide visual feedback.
-   */
-  onHoverIn?: ?(event: MouseEvent) => mixed,
-
-  /**
-   * Called when the hover is deactivated to undo visual feedback.
-   */
-  onHoverOut?: ?(event: MouseEvent) => mixed,
-
-  /**
-   * Called when a long press gesture has been triggered.
-   */
-  onLongPress?: ?(event: PressEvent) => mixed,
-
-  /**
-   * Called when a press gestute has been triggered.
-   */
-  onPress?: ?(event: PressEvent) => mixed,
-
-  /**
-   * Called when the press is activated to provide visual feedback.
-   */
-  onPressIn?: ?(event: PressEvent) => mixed,
-
-  /**
-   * Called when the press location moves. (This should rarely be used.)
-   */
-  onPressMove?: ?(event: PressEvent) => mixed,
-
-  /**
-   * Called when the press is deactivated to undo visual feedback.
-   */
-  onPressOut?: ?(event: PressEvent) => mixed,
-
-  /**
-   * Returns whether a long press gesture should cancel the press gesture.
-   * Defaults to true.
-   */
-  onLongPressShouldCancelPress_DEPRECATED?: ?() => boolean,
-
-  /**
-   * If `cancelable` is set, this will be ignored.
-   *
-   * Returns whether to yield to a lock termination request (e.g. if a native
-   * scroll gesture attempts to steal the responder lock).
-   */
-  onResponderTerminationRequest_DEPRECATED?: ?() => boolean,
-
-  /**
-   * If `disabled` is set, this will be ignored.
-   *
-   * Returns whether to start a press gesture.
-   *
-   * @deprecated
-   */
-  onStartShouldSetResponder_DEPRECATED?: ?() => boolean,
+    /**
+     * Whether to disable initialization of the press gesture.
+     */
+    disabled ?: ? boolean,
+
+    /**
+     * Amount to extend the `VisualRect` by to create `HitRect`.
+     */
+    hitSlop ?: ? RectOrSize,
+
+    /**
+     * Amount to extend the `HitRect` by to create `PressRect`.
+     */
+    pressRectOffset ?: ? RectOrSize,
+
+    /**
+     * Whether to disable the systemm sound when `onPress` fires on Android.
+     **/
+    android_disableSound ?: ? boolean,
+
+    /**
+     * Duration to wait after hover in before calling `onHoverIn`.
+     */
+    delayHoverIn ?: ? number,
+
+    /**
+     * Duration to wait after hover out before calling `onHoverOut`.
+     */
+    delayHoverOut ?: ? number,
+
+    /**
+     * Duration (in addition to `delayPressIn`) after which a press gesture is
+     * considered a long press gesture. Defaults to 500 (milliseconds).
+     */
+    delayLongPress ?: ? number,
+
+    /**
+     * Duration to wait after press down before calling `onPressIn`.
+     */
+    delayPressIn ?: ? number,
+
+    /**
+     * Duration to wait after letting up before calling `onPressOut`.
+     */
+    delayPressOut ?: ? number,
+
+    /**
+     * Minimum duration to wait between calling `onPressIn` and `onPressOut`.
+     */
+    minPressDuration ?: ? number,
+
+    /**
+     * Called after the element loses focus.
+     */
+    onBlur ?: ? (event: BlurEvent) => mixed,
+
+    /**
+     * Called after the element is focused.
+     */
+    onFocus ?: ? (event: FocusEvent) => mixed,
+
+    /**
+     * Called when the hover is activated to provide visual feedback.
+     */
+    onHoverIn ?: ? (event: MouseEvent) => mixed,
+
+    /**
+     * Called when the hover is deactivated to undo visual feedback.
+     */
+    onHoverOut ?: ? (event: MouseEvent) => mixed,
+
+    /**
+     * Called when a long press gesture has been triggered.
+     */
+    onLongPress ?: ? (event: PressEvent) => mixed,
+
+    /**
+     * Called when a press gestute has been triggered.
+     */
+    onPress ?: ? (event: PressEvent) => mixed,
+
+    /**
+     * Called when the press is activated to provide visual feedback.
+     */
+    onPressIn ?: ? (event: PressEvent) => mixed,
+
+    /**
+     * Called when the press location moves. (This should rarely be used.)
+     */
+    onPressMove ?: ? (event: PressEvent) => mixed,
+
+    /**
+     * Called when the press is deactivated to undo visual feedback.
+     */
+    onPressOut ?: ? (event: PressEvent) => mixed,
+
+    /**
+     * Returns whether a long press gesture should cancel the press gesture.
+     * Defaults to true.
+     */
+    onLongPressShouldCancelPress_DEPRECATED ?: ? () => boolean,
+
+    /**
+     * If `cancelable` is set, this will be ignored.
+     *
+     * Returns whether to yield to a lock termination request (e.g. if a native
+     * scroll gesture attempts to steal the responder lock).
+     */
+    onResponderTerminationRequest_DEPRECATED ?: ? () => boolean,
+
+    /**
+     * If `disabled` is set, this will be ignored.
+     *
+     * Returns whether to start a press gesture.
+     *
+     * @deprecated
+     */
+    onStartShouldSetResponder_DEPRECATED ?: ? () => boolean,
 |}>;
 
 export type EventHandlers = $ReadOnly<{|
   onBlur: (event: BlurEvent) => void,
-  onClick: (event: PressEvent) => void,
-  onFocus: (event: FocusEvent) => void,
-  onMouseEnter?: (event: MouseEvent) => void,
-  onMouseLeave?: (event: MouseEvent) => void,
-  onPointerEnter?: (event: PointerEvent) => void,
-  onPointerLeave?: (event: PointerEvent) => void,
-  onResponderGrant: (event: PressEvent) => void,
-  onResponderMove: (event: PressEvent) => void,
-  onResponderRelease: (event: PressEvent) => void,
-  onResponderTerminate: (event: PressEvent) => void,
-  onResponderTerminationRequest: () => boolean,
-  onStartShouldSetResponder: () => boolean,
+    onClick: (event: PressEvent) => void,
+      onFocus: (event: FocusEvent) => void,
+        onMouseEnter ?: (event: MouseEvent) => void,
+        onMouseLeave ?: (event: MouseEvent) => void,
+        onPointerEnter ?: (event: PointerEvent) => void,
+        onPointerLeave ?: (event: PointerEvent) => void,
+        onResponderGrant: (event: PressEvent) => void,
+          onResponderMove: (event: PressEvent) => void,
+            onResponderRelease: (event: PressEvent) => void,
+              onResponderTerminate: (event: PressEvent) => void,
+                onResponderTerminationRequest: () => boolean,
+                  onStartShouldSetResponder: () => boolean,
 |}>;
 
 type TouchState =
@@ -385,543 +385,543 @@ export default class Pressability {
   _responderID: ?number | React.ElementRef<HostComponent<mixed>> = null;
   _responderRegion: ?$ReadOnly<{|
     bottom: number,
-    left: number,
-    right: number,
-    top: number,
+      left: number,
+        right: number,
+          top: number,
   |}> = null;
-  _touchActivatePosition: ?$ReadOnly<{|
-    pageX: number,
-    pageY: number,
+_touchActivatePosition: ? $ReadOnly < {|
+  pageX : number,
+  pageY: number,
   |}>;
-  _touchActivateTime: ?number;
-  _touchState: TouchState = 'NOT_RESPONDER';
+_touchActivateTime: ? number;
+_touchState: TouchState = 'NOT_RESPONDER';
 
-  constructor(config: PressabilityConfig) {
-    this.configure(config);
-  }
+constructor(config: PressabilityConfig) {
+  this.configure(config);
+}
 
-  configure(config: PressabilityConfig): void {
-    this._config = config;
-  }
+configure(config: PressabilityConfig): void {
+  this._config = config;
+}
 
-  /**
-   * Resets any pending timers. This should be called on unmount.
-   */
-  reset(): void {
-    this._cancelHoverInDelayTimeout();
-    this._cancelHoverOutDelayTimeout();
-    this._cancelLongPressDelayTimeout();
-    this._cancelPressDelayTimeout();
-    this._cancelPressOutDelayTimeout();
-
-    // Ensure that, if any async event handlers are fired after unmount
-    // due to a race, we don't call any configured callbacks.
-    this._config = Object.freeze({});
-  }
+/**
+ * Resets any pending timers. This should be called on unmount.
+ */
+reset(): void {
+  this._cancelHoverInDelayTimeout();
+  this._cancelHoverOutDelayTimeout();
+  this._cancelLongPressDelayTimeout();
+  this._cancelPressDelayTimeout();
+  this._cancelPressOutDelayTimeout();
+
+  // Ensure that, if any async event handlers are fired after unmount
+  // due to a race, we don't call any configured callbacks.
+  this._config = Object.freeze({});
+}
 
-  /**
-   * Returns a set of props to spread into the interactive element.
-   */
-  getEventHandlers(): EventHandlers {
-    if (this._eventHandlers == null) {
-      this._eventHandlers = this._createEventHandlers();
-    }
-    return this._eventHandlers;
+/**
+ * Returns a set of props to spread into the interactive element.
+ */
+getEventHandlers(): EventHandlers {
+  if (this._eventHandlers == null) {
+    this._eventHandlers = this._createEventHandlers();
   }
+  return this._eventHandlers;
+}
 
-  _createEventHandlers(): EventHandlers {
-    const focusEventHandlers = {
-      onBlur: (event: BlurEvent): void => {
-        const {onBlur} = this._config;
-        if (onBlur != null) {
-          onBlur(event);
-        }
-      },
-      onFocus: (event: FocusEvent): void => {
-        const {onFocus} = this._config;
-        if (onFocus != null) {
-          onFocus(event);
-        }
-      },
-    };
+_createEventHandlers(): EventHandlers {
+  const focusEventHandlers = {
+    onBlur: (event: BlurEvent): void => {
+      const { onBlur } = this._config;
+      if (onBlur != null) {
+        onBlur(event);
+      }
+    },
+    onFocus: (event: FocusEvent): void => {
+      const { onFocus } = this._config;
+      if (onFocus != null) {
+        onFocus(event);
+      }
+    },
+  };
 
-    const responderEventHandlers = {
-      onStartShouldSetResponder: (): boolean => {
-        const {disabled} = this._config;
-        if (disabled == null) {
-          const {onStartShouldSetResponder_DEPRECATED} = this._config;
-          return onStartShouldSetResponder_DEPRECATED == null
-            ? true
-            : onStartShouldSetResponder_DEPRECATED();
-        }
-        return !disabled;
-      },
+  const responderEventHandlers = {
+    onStartShouldSetResponder: (): boolean => {
+      const { disabled } = this._config;
+      if (disabled == null) {
+        const { onStartShouldSetResponder_DEPRECATED } = this._config;
+        return onStartShouldSetResponder_DEPRECATED == null
+          ? true
+          : onStartShouldSetResponder_DEPRECATED();
+      }
+      return !disabled;
+    },
 
-      onResponderGrant: (event: PressEvent): void => {
-        event.persist();
+    onResponderGrant: (event: PressEvent): void => {
+      event.persist();
 
-        this._cancelPressOutDelayTimeout();
+      this._cancelPressOutDelayTimeout();
 
-        this._responderID = event.currentTarget;
-        this._touchState = 'NOT_RESPONDER';
-        this._receiveSignal('RESPONDER_GRANT', event);
+      this._responderID = event.currentTarget;
+      this._touchState = 'NOT_RESPONDER';
+      this._receiveSignal('RESPONDER_GRANT', event);
 
-        const delayPressIn = normalizeDelay(this._config.delayPressIn);
-        if (delayPressIn > 0) {
-          this._pressDelayTimeout = setTimeout(() => {
-            this._receiveSignal('DELAY', event);
-          }, delayPressIn);
-        } else {
+      const delayPressIn = normalizeDelay(this._config.delayPressIn);
+      if (delayPressIn > 0) {
+        this._pressDelayTimeout = setTimeout(() => {
           this._receiveSignal('DELAY', event);
-        }
+        }, delayPressIn);
+      } else {
+        this._receiveSignal('DELAY', event);
+      }
 
-        const delayLongPress = normalizeDelay(
-          this._config.delayLongPress,
-          10,
-          DEFAULT_LONG_PRESS_DELAY_MS - delayPressIn,
-        );
-        this._longPressDelayTimeout = setTimeout(() => {
-          this._handleLongPress(event);
-        }, delayLongPress + delayPressIn);
-      },
-
-      onResponderMove: (event: PressEvent): void => {
-        const {onPressMove} = this._config;
-        if (onPressMove != null) {
-          onPressMove(event);
-        }
+      const delayLongPress = normalizeDelay(
+        this._config.delayLongPress,
+        10,
+        DEFAULT_LONG_PRESS_DELAY_MS - delayPressIn,
+      );
+      this._longPressDelayTimeout = setTimeout(() => {
+        this._handleLongPress(event);
+      }, delayLongPress + delayPressIn);
+    },
 
-        // Region may not have finished being measured, yet.
-        const responderRegion = this._responderRegion;
-        if (responderRegion == null) {
-          return;
-        }
+    onResponderMove: (event: PressEvent): void => {
+      const { onPressMove } = this._config;
+      if (onPressMove != null) {
+        onPressMove(event);
+      }
 
-        const touch = getTouchFromPressEvent(event);
-        if (touch == null) {
-          this._cancelLongPressDelayTimeout();
-          this._receiveSignal('LEAVE_PRESS_RECT', event);
-          return;
-        }
+      // Region may not have finished being measured, yet.
+      const responderRegion = this._responderRegion;
+      if (responderRegion == null) {
+        return;
+      }
 
-        if (this._touchActivatePosition != null) {
-          const deltaX = this._touchActivatePosition.pageX - touch.pageX;
-          const deltaY = this._touchActivatePosition.pageY - touch.pageY;
-          if (Math.hypot(deltaX, deltaY) > 10) {
-            this._cancelLongPressDelayTimeout();
-          }
-        }
+      const touch = getTouchFromPressEvent(event);
+      if (touch == null) {
+        this._cancelLongPressDelayTimeout();
+        this._receiveSignal('LEAVE_PRESS_RECT', event);
+        return;
+      }
 
-        if (this._isTouchWithinResponderRegion(touch, responderRegion)) {
-          this._receiveSignal('ENTER_PRESS_RECT', event);
-        } else {
+      if (this._touchActivatePosition != null) {
+        const deltaX = this._touchActivatePosition.pageX - touch.pageX;
+        const deltaY = this._touchActivatePosition.pageY - touch.pageY;
+        if (Math.hypot(deltaX, deltaY) > 10) {
           this._cancelLongPressDelayTimeout();
-          this._receiveSignal('LEAVE_PRESS_RECT', event);
-        }
-      },
-
-      onResponderRelease: (event: PressEvent): void => {
-        this._receiveSignal('RESPONDER_RELEASE', event);
-      },
-
-      onResponderTerminate: (event: PressEvent): void => {
-        this._receiveSignal('RESPONDER_TERMINATED', event);
-      },
-
-      onResponderTerminationRequest: (): boolean => {
-        const {cancelable} = this._config;
-        if (cancelable == null) {
-          const {onResponderTerminationRequest_DEPRECATED} = this._config;
-          return onResponderTerminationRequest_DEPRECATED == null
-            ? true
-            : onResponderTerminationRequest_DEPRECATED();
         }
-        return cancelable;
-      },
+      }
 
-      onClick: (event: PressEvent): void => {
-        const {onPress, disabled} = this._config;
-        if (onPress != null && disabled !== true) {
-          onPress(event);
-        }
-      },
-    };
+      if (this._isTouchWithinResponderRegion(touch, responderRegion)) {
+        this._receiveSignal('ENTER_PRESS_RECT', event);
+      } else {
+        this._cancelLongPressDelayTimeout();
+        this._receiveSignal('LEAVE_PRESS_RECT', event);
+      }
+    },
 
-    if (process.env.NODE_ENV === 'test') {
-      // We are setting this in order to find this node in ReactNativeTestTools
-      responderEventHandlers.onStartShouldSetResponder.testOnly_pressabilityConfig =
-        () => this._config;
-    }
+    onResponderRelease: (event: PressEvent): void => {
+      this._receiveSignal('RESPONDER_RELEASE', event);
+    },
 
-    if (
-      ReactNativeFeatureFlags.shouldPressibilityUseW3CPointerEventsForHover()
-    ) {
-      const hoverPointerEvents = {
-        onPointerEnter: undefined,
-        onPointerLeave: undefined,
-      };
-      const {onHoverIn, onHoverOut} = this._config;
-      if (onHoverIn != null) {
-        hoverPointerEvents.onPointerEnter = (event: PointerEvent) => {
-          this._isHovered = true;
-          this._cancelHoverOutDelayTimeout();
-          if (onHoverIn != null) {
-            const delayHoverIn = normalizeDelay(this._config.delayHoverIn);
-            if (delayHoverIn > 0) {
-              event.persist();
-              this._hoverInDelayTimeout = setTimeout(() => {
-                onHoverIn(convertPointerEventToMouseEvent(event));
-              }, delayHoverIn);
-            } else {
+    onResponderTerminate: (event: PressEvent): void => {
+      this._receiveSignal('RESPONDER_TERMINATED', event);
+    },
+
+    onResponderTerminationRequest: (): boolean => {
+      const { cancelable } = this._config;
+      if (cancelable == null) {
+        const { onResponderTerminationRequest_DEPRECATED } = this._config;
+        return onResponderTerminationRequest_DEPRECATED == null
+          ? true
+          : onResponderTerminationRequest_DEPRECATED();
+      }
+      return cancelable;
+    },
+
+    onClick: (event: PressEvent): void => {
+      const { onPress, disabled } = this._config;
+      if (onPress != null && disabled !== true) {
+        onPress(event);
+      }
+    },
+  };
+
+  if (process.env.NODE_ENV === 'test') {
+    // We are setting this in order to find this node in ReactNativeTestTools
+    responderEventHandlers.onStartShouldSetResponder.testOnly_pressabilityConfig =
+      () => this._config;
+  }
+
+  if (
+    ReactNativeFeatureFlags.shouldPressibilityUseW3CPointerEventsForHover()
+  ) {
+    const hoverPointerEvents = {
+      onPointerEnter: undefined,
+      onPointerLeave: undefined,
+    };
+    const { onHoverIn, onHoverOut } = this._config;
+    if (onHoverIn != null) {
+      hoverPointerEvents.onPointerEnter = (event: PointerEvent) => {
+        this._isHovered = true;
+        this._cancelHoverOutDelayTimeout();
+        if (onHoverIn != null) {
+          const delayHoverIn = normalizeDelay(this._config.delayHoverIn);
+          if (delayHoverIn > 0) {
+            event.persist();
+            this._hoverInDelayTimeout = setTimeout(() => {
               onHoverIn(convertPointerEventToMouseEvent(event));
-            }
+            }, delayHoverIn);
+          } else {
+            onHoverIn(convertPointerEventToMouseEvent(event));
           }
-        };
-      }
-      if (onHoverOut != null) {
-        hoverPointerEvents.onPointerLeave = (event: PointerEvent) => {
-          if (this._isHovered) {
-            this._isHovered = false;
-            this._cancelHoverInDelayTimeout();
-            if (onHoverOut != null) {
-              const delayHoverOut = normalizeDelay(this._config.delayHoverOut);
-              if (delayHoverOut > 0) {
-                event.persist();
-                this._hoverOutDelayTimeout = setTimeout(() => {
-                  onHoverOut(convertPointerEventToMouseEvent(event));
-                }, delayHoverOut);
-              } else {
+        }
+      };
+    }
+    if (onHoverOut != null) {
+      hoverPointerEvents.onPointerLeave = (event: PointerEvent) => {
+        if (this._isHovered) {
+          this._isHovered = false;
+          this._cancelHoverInDelayTimeout();
+          if (onHoverOut != null) {
+            const delayHoverOut = normalizeDelay(this._config.delayHoverOut);
+            if (delayHoverOut > 0) {
+              event.persist();
+              this._hoverOutDelayTimeout = setTimeout(() => {
                 onHoverOut(convertPointerEventToMouseEvent(event));
-              }
+              }, delayHoverOut);
+            } else {
+              onHoverOut(convertPointerEventToMouseEvent(event));
             }
           }
-        };
-      }
-      return {
-        ...focusEventHandlers,
-        ...responderEventHandlers,
-        ...hoverPointerEvents,
+        }
       };
-    } else {
-      const mouseEventHandlers =
-        Platform.OS === 'ios' || Platform.OS === 'android'
-          ? null
-          : {
-              onMouseEnter: (event: MouseEvent): void => {
-                if (isHoverEnabled()) {
-                  this._isHovered = true;
-                  this._cancelHoverOutDelayTimeout();
-                  const {onHoverIn} = this._config;
-                  if (onHoverIn != null) {
-                    const delayHoverIn = normalizeDelay(
-                      this._config.delayHoverIn,
-                    );
-                    if (delayHoverIn > 0) {
-                      event.persist();
-                      this._hoverInDelayTimeout = setTimeout(() => {
-                        onHoverIn(event);
-                      }, delayHoverIn);
-                    } else {
-                      onHoverIn(event);
-                    }
-                  }
+    }
+    return {
+      ...focusEventHandlers,
+      ...responderEventHandlers,
+      ...hoverPointerEvents,
+    };
+  } else {
+    const mouseEventHandlers =
+      Platform.OS === 'ios' || Platform.OS === 'android'
+        ? null
+        : {
+          onMouseEnter: (event: MouseEvent): void => {
+            if (isHoverEnabled()) {
+              this._isHovered = true;
+              this._cancelHoverOutDelayTimeout();
+              const { onHoverIn } = this._config;
+              if (onHoverIn != null) {
+                const delayHoverIn = normalizeDelay(
+                  this._config.delayHoverIn,
+                );
+                if (delayHoverIn > 0) {
+                  event.persist();
+                  this._hoverInDelayTimeout = setTimeout(() => {
+                    onHoverIn(event);
+                  }, delayHoverIn);
+                } else {
+                  onHoverIn(event);
                 }
-              },
-
-              onMouseLeave: (event: MouseEvent): void => {
-                if (this._isHovered) {
-                  this._isHovered = false;
-                  this._cancelHoverInDelayTimeout();
-                  const {onHoverOut} = this._config;
-                  if (onHoverOut != null) {
-                    const delayHoverOut = normalizeDelay(
-                      this._config.delayHoverOut,
-                    );
-                    if (delayHoverOut > 0) {
-                      event.persist();
-                      this._hoverInDelayTimeout = setTimeout(() => {
-                        onHoverOut(event);
-                      }, delayHoverOut);
-                    } else {
-                      onHoverOut(event);
-                    }
-                  }
+              }
+            }
+          },
+
+          onMouseLeave: (event: MouseEvent): void => {
+            if (this._isHovered) {
+              this._isHovered = false;
+              this._cancelHoverInDelayTimeout();
+              const { onHoverOut } = this._config;
+              if (onHoverOut != null) {
+                const delayHoverOut = normalizeDelay(
+                  this._config.delayHoverOut,
+                );
+                if (delayHoverOut > 0) {
+                  event.persist();
+                  this._hoverInDelayTimeout = setTimeout(() => {
+                    onHoverOut(event);
+                  }, delayHoverOut);
+                } else {
+                  onHoverOut(event);
                 }
-              },
-            };
-      return {
-        ...focusEventHandlers,
-        ...responderEventHandlers,
-        ...mouseEventHandlers,
-      };
-    }
-  }
-
-  /**
-   * Receives a state machine signal, performs side effects of the transition
-   * and stores the new state. Validates the transition as well.
-   */
-  _receiveSignal(signal: TouchSignal, event: PressEvent): void {
-    // Especially on iOS, not all events have timestamps associated.
-    // For telemetry purposes, this doesn't matter too much, as long as *some* do.
-    // Since the native timestamp is integral for logging telemetry, just skip
-    // events if they don't have a timestamp attached.
-    if (event.nativeEvent.timestamp != null) {
-      PressabilityPerformanceEventEmitter.emitEvent(() => {
-        return {
-          signal,
-          nativeTimestamp: event.nativeEvent.timestamp,
+              }
+            }
+          },
         };
-      });
-    }
+    return {
+      ...focusEventHandlers,
+      ...responderEventHandlers,
+      ...mouseEventHandlers,
+    };
+  }
+}
 
-    const prevState = this._touchState;
-    const nextState = Transitions[prevState]?.[signal];
-    if (this._responderID == null && signal === 'RESPONDER_RELEASE') {
-      return;
-    }
-    invariant(
-      nextState != null && nextState !== 'ERROR',
-      'Pressability: Invalid signal `%s` for state `%s` on responder: %s',
+/**
+ * Receives a state machine signal, performs side effects of the transition
+ * and stores the new state. Validates the transition as well.
+ */
+_receiveSignal(signal: TouchSignal, event: PressEvent): void {
+  // Especially on iOS, not all events have timestamps associated.
+  // For telemetry purposes, this doesn't matter too much, as long as *some* do.
+  // Since the native timestamp is integral for logging telemetry, just skip
+  // events if they don't have a timestamp attached.
+  if(event.nativeEvent.timestamp != null) {
+  PressabilityPerformanceEventEmitter.emitEvent(() => {
+    return {
       signal,
-      prevState,
-      typeof this._responderID === 'number'
-        ? this._responderID
-        : '<<host component>>',
-    );
-    if (prevState !== nextState) {
-      this._performTransitionSideEffects(prevState, nextState, signal, event);
-      this._touchState = nextState;
-    }
+      nativeTimestamp: event.nativeEvent.timestamp,
+    };
+  });
+}
+
+const prevState = this._touchState;
+const nextState = Transitions[prevState]?.[signal];
+if (this._responderID == null && signal === 'RESPONDER_RELEASE') {
+  return;
+}
+invariant(
+  nextState != null && nextState !== 'ERROR',
+  'Pressability: Invalid signal `%s` for state `%s` on responder: %s',
+  signal,
+  prevState,
+  typeof this._responderID === 'number'
+    ? this._responderID
+    : '<<host component>>',
+);
+if (prevState !== nextState) {
+  this._performTransitionSideEffects(prevState, nextState, signal, event);
+  this._touchState = nextState;
+}
   }
 
-  /**
-   * Performs a transition between touchable states and identify any activations
-   * or deactivations (and callback invocations).
-   */
-  _performTransitionSideEffects(
-    prevState: TouchState,
-    nextState: TouchState,
-    signal: TouchSignal,
-    event: PressEvent,
-  ): void {
-    if (isTerminalSignal(signal)) {
-      this._touchActivatePosition = null;
-      this._cancelLongPressDelayTimeout();
-    }
+/**
+ * Performs a transition between touchable states and identify any activations
+ * or deactivations (and callback invocations).
+ */
+_performTransitionSideEffects(
+  prevState: TouchState,
+  nextState: TouchState,
+  signal: TouchSignal,
+  event: PressEvent,
+): void {
+  if(isTerminalSignal(signal)) {
+  this._touchActivatePosition = null;
+  this._cancelLongPressDelayTimeout();
+}
 
-    const isInitialTransition =
-      prevState === 'NOT_RESPONDER' &&
-      nextState === 'RESPONDER_INACTIVE_PRESS_IN';
+const isInitialTransition =
+  prevState === 'NOT_RESPONDER' &&
+  nextState === 'RESPONDER_INACTIVE_PRESS_IN';
 
-    const isActivationTransition =
-      !isActivationSignal(prevState) && isActivationSignal(nextState);
+const isActivationTransition =
+  !isActivationSignal(prevState) && isActivationSignal(nextState);
 
-    if (isInitialTransition || isActivationTransition) {
-      this._measureResponderRegion();
-    }
+if (isInitialTransition || isActivationTransition) {
+  this._measureResponderRegion();
+}
 
-    if (isPressInSignal(prevState) && signal === 'LONG_PRESS_DETECTED') {
-      const {onLongPress} = this._config;
-      if (onLongPress != null) {
-        onLongPress(event);
-      }
-    }
+if (isPressInSignal(prevState) && signal === 'LONG_PRESS_DETECTED') {
+  const { onLongPress } = this._config;
+  if (onLongPress != null) {
+    onLongPress(event);
+  }
+}
 
-    const isPrevActive = isActiveSignal(prevState);
-    const isNextActive = isActiveSignal(nextState);
+const isPrevActive = isActiveSignal(prevState);
+const isNextActive = isActiveSignal(nextState);
 
-    if (!isPrevActive && isNextActive) {
-      this._activate(event);
-    } else if (isPrevActive && !isNextActive) {
-      this._deactivate(event);
-    }
+if (!isPrevActive && isNextActive) {
+  this._activate(event);
+} else if (isPrevActive && !isNextActive) {
+  this._deactivate(event);
+}
 
-    if (isPressInSignal(prevState) && signal === 'RESPONDER_RELEASE') {
-      // If we never activated (due to delays), activate and deactivate now.
-      if (!isNextActive && !isPrevActive) {
-        this._activate(event);
-        this._deactivate(event);
-      }
-      const {onLongPress, onPress, android_disableSound} = this._config;
-      if (onPress != null) {
-        const isPressCanceledByLongPress =
-          onLongPress != null &&
-          prevState === 'RESPONDER_ACTIVE_LONG_PRESS_IN' &&
-          this._shouldLongPressCancelPress();
-        if (!isPressCanceledByLongPress) {
-          if (Platform.OS === 'android' && android_disableSound !== true) {
-            SoundManager.playTouchSound();
-          }
-          onPress(event);
-        }
+if (isPressInSignal(prevState) && signal === 'RESPONDER_RELEASE') {
+  // If we never activated (due to delays), activate and deactivate now.
+  if (!isNextActive && !isPrevActive) {
+    this._activate(event);
+    this._deactivate(event);
+  }
+  const { onLongPress, onPress, android_disableSound } = this._config;
+  if (onPress != null) {
+    const isPressCanceledByLongPress =
+      onLongPress != null &&
+      prevState === 'RESPONDER_ACTIVE_LONG_PRESS_IN' &&
+      this._shouldLongPressCancelPress();
+    if (!isPressCanceledByLongPress) {
+      if (Platform.OS === 'android' && android_disableSound !== true) {
+        SoundManager.playTouchSound();
       }
+      onPress(event);
     }
+  }
+}
 
-    this._cancelPressDelayTimeout();
+this._cancelPressDelayTimeout();
   }
 
-  _activate(event: PressEvent): void {
-    const {onPressIn} = this._config;
-    const {pageX, pageY} = getTouchFromPressEvent(event);
-    this._touchActivatePosition = {pageX, pageY};
-    this._touchActivateTime = Date.now();
-    if (onPressIn != null) {
-      onPressIn(event);
-    }
+_activate(event: PressEvent): void {
+  const { onPressIn } = this._config;
+  const { pageX, pageY } = getTouchFromPressEvent(event);
+  this._touchActivatePosition = { pageX, pageY };
+  this._touchActivateTime = Date.now();
+  if(onPressIn != null) {
+  onPressIn(event);
+}
   }
 
-  _deactivate(event: PressEvent): void {
-    const {onPressOut} = this._config;
-    if (onPressOut != null) {
-      const minPressDuration = normalizeDelay(
-        this._config.minPressDuration,
-        0,
-        DEFAULT_MIN_PRESS_DURATION,
-      );
-      const pressDuration = Date.now() - (this._touchActivateTime ?? 0);
-      const delayPressOut = Math.max(
-        minPressDuration - pressDuration,
-        normalizeDelay(this._config.delayPressOut),
-      );
-      if (delayPressOut > 0) {
-        event.persist();
-        this._pressOutDelayTimeout = setTimeout(() => {
-          onPressOut(event);
-        }, delayPressOut);
-      } else {
-        onPressOut(event);
-      }
-    }
-    this._touchActivateTime = null;
+_deactivate(event: PressEvent): void {
+  const { onPressOut } = this._config;
+  if(onPressOut != null) {
+  const minPressDuration = normalizeDelay(
+    this._config.minPressDuration,
+    0,
+    DEFAULT_MIN_PRESS_DURATION,
+  );
+  const pressDuration = Date.now() - (this._touchActivateTime ?? 0);
+  const delayPressOut = Math.max(
+    minPressDuration - pressDuration,
+    normalizeDelay(this._config.delayPressOut),
+  );
+  if (delayPressOut > 0) {
+    event.persist();
+    this._pressOutDelayTimeout = setTimeout(() => {
+      onPressOut(event);
+    }, delayPressOut);
+  } else {
+    onPressOut(event);
+  }
+}
+this._touchActivateTime = null;
   }
 
-  _measureResponderRegion(): void {
-    if (this._responderID == null) {
-      return;
-    }
+_measureResponderRegion(): void {
+  if(this._responderID == null) {
+  return;
+}
 
-    if (typeof this._responderID === 'number') {
-      UIManager.measure(this._responderID, this._measureCallback);
-    } else {
-      this._responderID.measure(this._measureCallback);
-    }
+if (typeof this._responderID === 'number') {
+  UIManager.measure(this._responderID, this._measureCallback);
+} else {
+  this._responderID.measure(this._measureCallback);
+}
   }
 
-  _measureCallback = (
-    left: number,
-    top: number,
-    width: number,
-    height: number,
-    pageX: number,
-    pageY: number,
-  ) => {
-    if (!left && !top && !width && !height && !pageX && !pageY) {
-      return;
-    }
-    this._responderRegion = {
-      bottom: pageY + height,
-      left: pageX,
-      right: pageX + width,
-      top: pageY,
-    };
+_measureCallback = (
+  left: number,
+  top: number,
+  width: number,
+  height: number,
+  pageX: number,
+  pageY: number,
+) => {
+  if (!left && !top && !width && !height && !pageX && !pageY) {
+    return;
+  }
+  this._responderRegion = {
+    bottom: pageY + height,
+    left: pageX,
+    right: pageX + width,
+    top: pageY,
   };
+};
 
-  _isTouchWithinResponderRegion(
-    touch: $PropertyType<PressEvent, 'nativeEvent'>,
-    responderRegion: $ReadOnly<{|
-      bottom: number,
-      left: number,
-      right: number,
-      top: number,
+_isTouchWithinResponderRegion(
+  touch: $PropertyType < PressEvent, 'nativeEvent' >,
+  responderRegion: $ReadOnly < {|
+bottom: number,
+  left: number,
+  right: number,
+  top: number,
     |}>,
-  ): boolean {
-    const hitSlop = normalizeRect(this._config.hitSlop);
-    const pressRectOffset = normalizeRect(this._config.pressRectOffset);
-
-    let regionBottom = responderRegion.bottom;
-    let regionLeft = responderRegion.left;
-    let regionRight = responderRegion.right;
-    let regionTop = responderRegion.top;
-
-    if (hitSlop != null) {
-      if (hitSlop.bottom != null) {
-        regionBottom += hitSlop.bottom;
-      }
-      if (hitSlop.left != null) {
-        regionLeft -= hitSlop.left;
-      }
-      if (hitSlop.right != null) {
-        regionRight += hitSlop.right;
-      }
-      if (hitSlop.top != null) {
-        regionTop -= hitSlop.top;
-      }
+): boolean {
+  const hitSlop = normalizeRect(this._config.hitSlop);
+  const pressRectOffset = normalizeRect(this._config.pressRectOffset);
+
+  let regionBottom = responderRegion.bottom;
+  let regionLeft = responderRegion.left;
+  let regionRight = responderRegion.right;
+  let regionTop = responderRegion.top;
+
+  if (hitSlop != null) {
+    if (hitSlop.bottom != null) {
+      regionBottom += hitSlop.bottom;
+    }
+    if (hitSlop.left != null) {
+      regionLeft -= hitSlop.left;
+    }
+    if (hitSlop.right != null) {
+      regionRight += hitSlop.right;
+    }
+    if (hitSlop.top != null) {
+      regionTop -= hitSlop.top;
     }
-
-    regionBottom +=
-      pressRectOffset?.bottom ?? DEFAULT_PRESS_RECT_OFFSETS.bottom;
-    regionLeft -= pressRectOffset?.left ?? DEFAULT_PRESS_RECT_OFFSETS.left;
-    regionRight += pressRectOffset?.right ?? DEFAULT_PRESS_RECT_OFFSETS.right;
-    regionTop -= pressRectOffset?.top ?? DEFAULT_PRESS_RECT_OFFSETS.top;
-
-    return (
-      touch.pageX > regionLeft &&
-      touch.pageX < regionRight &&
-      touch.pageY > regionTop &&
-      touch.pageY < regionBottom
-    );
   }
 
-  _handleLongPress(event: PressEvent): void {
-    if (
-      this._touchState === 'RESPONDER_ACTIVE_PRESS_IN' ||
+  regionBottom +=
+    pressRectOffset?.bottom ?? DEFAULT_PRESS_RECT_OFFSETS.bottom;
+  regionLeft -= pressRectOffset?.left ?? DEFAULT_PRESS_RECT_OFFSETS.left;
+  regionRight += pressRectOffset?.right ?? DEFAULT_PRESS_RECT_OFFSETS.right;
+  regionTop -= pressRectOffset?.top ?? DEFAULT_PRESS_RECT_OFFSETS.top;
+
+  return (
+    touch.pageX > regionLeft &&
+    touch.pageX < regionRight &&
+    touch.pageY > regionTop &&
+    touch.pageY < regionBottom
+  );
+}
+
+_handleLongPress(event: PressEvent): void {
+  if(
+    this._touchState === 'RESPONDER_ACTIVE_PRESS_IN' ||
       this._touchState === 'RESPONDER_ACTIVE_LONG_PRESS_IN'
     ) {
-      this._receiveSignal('LONG_PRESS_DETECTED', event);
-    }
+  this._receiveSignal('LONG_PRESS_DETECTED', event);
+}
   }
 
-  _shouldLongPressCancelPress(): boolean {
-    return (
-      this._config.onLongPressShouldCancelPress_DEPRECATED == null ||
-      this._config.onLongPressShouldCancelPress_DEPRECATED()
-    );
-  }
+_shouldLongPressCancelPress(): boolean {
+  return (
+    this._config.onLongPressShouldCancelPress_DEPRECATED == null ||
+    this._config.onLongPressShouldCancelPress_DEPRECATED()
+  );
+}
 
-  _cancelHoverInDelayTimeout(): void {
-    if (this._hoverInDelayTimeout != null) {
-      clearTimeout(this._hoverInDelayTimeout);
-      this._hoverInDelayTimeout = null;
-    }
+_cancelHoverInDelayTimeout(): void {
+  if(this._hoverInDelayTimeout != null) {
+  clearTimeout(this._hoverInDelayTimeout);
+  this._hoverInDelayTimeout = null;
+}
   }
 
-  _cancelHoverOutDelayTimeout(): void {
-    if (this._hoverOutDelayTimeout != null) {
-      clearTimeout(this._hoverOutDelayTimeout);
-      this._hoverOutDelayTimeout = null;
-    }
+_cancelHoverOutDelayTimeout(): void {
+  if(this._hoverOutDelayTimeout != null) {
+  clearTimeout(this._hoverOutDelayTimeout);
+  this._hoverOutDelayTimeout = null;
+}
   }
 
-  _cancelLongPressDelayTimeout(): void {
-    if (this._longPressDelayTimeout != null) {
-      clearTimeout(this._longPressDelayTimeout);
-      this._longPressDelayTimeout = null;
-    }
+_cancelLongPressDelayTimeout(): void {
+  if(this._longPressDelayTimeout != null) {
+  clearTimeout(this._longPressDelayTimeout);
+  this._longPressDelayTimeout = null;
+}
   }
 
-  _cancelPressDelayTimeout(): void {
-    if (this._pressDelayTimeout != null) {
-      clearTimeout(this._pressDelayTimeout);
-      this._pressDelayTimeout = null;
-    }
+_cancelPressDelayTimeout(): void {
+  if(this._pressDelayTimeout != null) {
+  clearTimeout(this._pressDelayTimeout);
+  this._pressDelayTimeout = null;
+}
   }
 
-  _cancelPressOutDelayTimeout(): void {
-    if (this._pressOutDelayTimeout != null) {
-      clearTimeout(this._pressOutDelayTimeout);
-      this._pressOutDelayTimeout = null;
-    }
+_cancelPressOutDelayTimeout(): void {
+  if(this._pressOutDelayTimeout != null) {
+  clearTimeout(this._pressOutDelayTimeout);
+  this._pressOutDelayTimeout = null;
+}
   }
 }
 
@@ -934,7 +934,7 @@ function normalizeDelay(
 }
 
 const getTouchFromPressEvent = (event: PressEvent) => {
-  const {changedTouches, touches} = event.nativeEvent;
+  const { changedTouches, touches } = event.nativeEvent;
 
   if (touches != null && touches.length > 0) {
     return touches[0];
@@ -946,7 +946,7 @@ const getTouchFromPressEvent = (event: PressEvent) => {
 };
 
 function convertPointerEventToMouseEvent(input: PointerEvent): MouseEvent {
-  const {clientX, clientY} = input.nativeEvent;
+  const { clientX, clientY } = input.nativeEvent;
   return {
     ...input,
     nativeEvent: {
diff --git a/node_modules/react-native/index.js b/node_modules/react-native/index.js
index d59ba34..fc0c197 100644
--- a/node_modules/react-native/index.js
+++ b/node_modules/react-native/index.js
@@ -87,16 +87,16 @@ import typeof Vibration from './Libraries/Vibration/Vibration';
 import typeof YellowBox from './Libraries/YellowBox/YellowBoxDeprecated';
 
 // Plugins
-import typeof {DynamicColorIOS} from './Libraries/StyleSheet/PlatformColorValueTypesIOS';
+import typeof { DynamicColorIOS } from './Libraries/StyleSheet/PlatformColorValueTypesIOS';
 import typeof NativeModules from './Libraries/BatchedBridge/NativeModules';
 import typeof Platform from './Libraries/Utilities/Platform';
-import typeof {PlatformColor} from './Libraries/StyleSheet/PlatformColorValueTypes';
+import typeof { PlatformColor } from './Libraries/StyleSheet/PlatformColorValueTypes';
 import typeof processColor from './Libraries/StyleSheet/processColor';
 import typeof RCTDeviceEventEmitter from './Libraries/EventEmitter/RCTDeviceEventEmitter';
 import typeof RCTNativeAppEventEmitter from './Libraries/EventEmitter/RCTNativeAppEventEmitter';
-import typeof {RootTagContext} from './Libraries/ReactNative/RootTag';
+import typeof { RootTagContext } from './Libraries/ReactNative/RootTag';
 
-import type {HostComponent as _HostComponentInternal} from './Libraries/Renderer/shims/ReactNativeTypes';
+import type { HostComponent as _HostComponentInternal } from './Libraries/Renderer/shims/ReactNativeTypes';
 
 export type HostComponent<T> = _HostComponentInternal<T>;
 
@@ -120,8 +120,8 @@ module.exports = {
     warnOnce(
       'DatePickerIOS-merged',
       'DatePickerIOS has been merged with DatePickerAndroid and will be removed in a future release. ' +
-        "It can now be installed and imported from '@react-native-community/datetimepicker' instead of 'react-native'. " +
-        'See https://github.com/react-native-datetimepicker/datetimepicker',
+      "It can now be installed and imported from '@react-native-community/datetimepicker' instead of 'react-native'. " +
+      'See https://github.com/react-native-datetimepicker/datetimepicker',
     );
     return require('./Libraries/Components/DatePicker/DatePickerIOS');
   },
@@ -149,8 +149,8 @@ module.exports = {
     warnOnce(
       'maskedviewios-moved',
       'MaskedViewIOS has been extracted from react-native core and will be removed in a future release. ' +
-        "It can now be installed and imported from '@react-native-masked-view/masked-view' instead of 'react-native'. " +
-        'See https://github.com/react-native-masked-view/masked-view',
+      "It can now be installed and imported from '@react-native-masked-view/masked-view' instead of 'react-native'. " +
+      'See https://github.com/react-native-masked-view/masked-view',
     );
     return require('./Libraries/Components/MaskedView/MaskedViewIOS');
   },
@@ -165,8 +165,8 @@ module.exports = {
     warnOnce(
       'progress-bar-android-moved',
       'ProgressBarAndroid has been extracted from react-native core and will be removed in a future release. ' +
-        "It can now be installed and imported from '@react-native-community/progress-bar-android' instead of 'react-native'. " +
-        'See https://github.com/react-native-progress-view/progress-bar-android',
+      "It can now be installed and imported from '@react-native-community/progress-bar-android' instead of 'react-native'. " +
+      'See https://github.com/react-native-progress-view/progress-bar-android',
     );
     return require('./Libraries/Components/ProgressBarAndroid/ProgressBarAndroid');
   },
@@ -175,8 +175,8 @@ module.exports = {
     warnOnce(
       'progress-view-ios-moved',
       'ProgressViewIOS has been extracted from react-native core and will be removed in a future release. ' +
-        "It can now be installed and imported from '@react-native-community/progress-view' instead of 'react-native'. " +
-        'See https://github.com/react-native-progress-view/progress-view',
+      "It can now be installed and imported from '@react-native-community/progress-view' instead of 'react-native'. " +
+      'See https://github.com/react-native-progress-view/progress-view',
     );
     return require('./Libraries/Components/ProgressViewIOS/ProgressViewIOS');
   },
@@ -196,8 +196,8 @@ module.exports = {
     warnOnce(
       'slider-moved',
       'Slider has been extracted from react-native core and will be removed in a future release. ' +
-        "It can now be installed and imported from '@react-native-community/slider' instead of 'react-native'. " +
-        'See https://github.com/callstack/react-native-slider',
+      "It can now be installed and imported from '@react-native-community/slider' instead of 'react-native'. " +
+      'See https://github.com/callstack/react-native-slider',
     );
     return require('./Libraries/Components/Slider/Slider');
   },
@@ -262,8 +262,8 @@ module.exports = {
     warnOnce(
       'async-storage-moved',
       'AsyncStorage has been extracted from react-native core and will be removed in a future release. ' +
-        "It can now be installed and imported from '@react-native-async-storage/async-storage' instead of 'react-native'. " +
-        'See https://github.com/react-native-async-storage/async-storage',
+      "It can now be installed and imported from '@react-native-async-storage/async-storage' instead of 'react-native'. " +
+      'See https://github.com/react-native-async-storage/async-storage',
     );
     return require('./Libraries/Storage/AsyncStorage');
   },
@@ -274,8 +274,8 @@ module.exports = {
     warnOnce(
       'clipboard-moved',
       'Clipboard has been extracted from react-native core and will be removed in a future release. ' +
-        "It can now be installed and imported from '@react-native-clipboard/clipboard' instead of 'react-native'. " +
-        'See https://github.com/react-native-clipboard/clipboard',
+      "It can now be installed and imported from '@react-native-clipboard/clipboard' instead of 'react-native'. " +
+      'See https://github.com/react-native-clipboard/clipboard',
     );
     return require('./Libraries/Components/Clipboard/Clipboard');
   },
@@ -301,9 +301,9 @@ module.exports = {
     warnOnce(
       'imagePickerIOS-moved',
       'ImagePickerIOS has been extracted from react-native core and will be removed in a future release. ' +
-        "Please upgrade to use either '@react-native-community/react-native-image-picker' or 'expo-image-picker'. " +
-        "If you cannot upgrade to a different library, please install the deprecated '@react-native-community/image-picker-ios' package. " +
-        'See https://github.com/rnc-archive/react-native-image-picker-ios',
+      "Please upgrade to use either '@react-native-community/react-native-image-picker' or 'expo-image-picker'. " +
+      "If you cannot upgrade to a different library, please install the deprecated '@react-native-community/image-picker-ios' package. " +
+      'See https://github.com/rnc-archive/react-native-image-picker-ios',
     );
     return require('./Libraries/Image/ImagePickerIOS');
   },
@@ -345,8 +345,8 @@ module.exports = {
     warnOnce(
       'pushNotificationIOS-moved',
       'PushNotificationIOS has been extracted from react-native core and will be removed in a future release. ' +
-        "It can now be installed and imported from '@react-native-community/push-notification-ios' instead of 'react-native'. " +
-        'See https://github.com/react-native-push-notification-ios/push-notification-ios',
+      "It can now be installed and imported from '@react-native-community/push-notification-ios' instead of 'react-native'. " +
+      'See https://github.com/react-native-push-notification-ios/push-notification-ios',
     );
     return require('./Libraries/PushNotificationIOS/PushNotificationIOS');
   },
@@ -434,306 +434,291 @@ module.exports = {
       );
   },
   // Deprecated Prop Types
+
   get ColorPropType(): $FlowFixMe {
-    invariant(
-      false,
-      'ColorPropType has been removed from React Native. Migrate to ' +
-        "ColorPropType exported from 'deprecated-react-native-prop-types'.",
-    );
+    return require("deprecated-react-native-prop-types").ColorPropType
   },
   get EdgeInsetsPropType(): $FlowFixMe {
-    invariant(
-      false,
-      'EdgeInsetsPropType has been removed from React Native. Migrate to ' +
-        "EdgeInsetsPropType exported from 'deprecated-react-native-prop-types'.",
-    );
+    return require("deprecated-react-native-prop-types").EdgeInsetsPropType
   },
   get PointPropType(): $FlowFixMe {
-    invariant(
-      false,
-      'PointPropType has been removed from React Native. Migrate to ' +
-        "PointPropType exported from 'deprecated-react-native-prop-types'.",
-    );
+    return require("deprecated-react-native-prop-types").PointPropType
   },
   get ViewPropTypes(): $FlowFixMe {
-    invariant(
-      false,
-      'ViewPropTypes has been removed from React Native. Migrate to ' +
-        "ViewPropTypes exported from 'deprecated-react-native-prop-types'.",
-    );
+    return require("deprecated-react-native-prop-types").ViewPropTypes
   },
-};
 
-if (__DEV__) {
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access ART. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access ART. */
-  Object.defineProperty(module.exports, 'ART', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'ART has been removed from React Native. ' +
+
+  if(__DEV__) {
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access ART. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access ART. */
+    Object.defineProperty(module.exports, 'ART', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'ART has been removed from React Native. ' +
           "It can now be installed and imported from '@react-native-community/art' instead of 'react-native'. " +
           'See https://github.com/react-native-art/art',
-      );
-    },
-  });
+        );
+      },
+    });
 
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access ListView. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access ListView. */
-  Object.defineProperty(module.exports, 'ListView', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'ListView has been removed from React Native. ' +
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access ListView. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access ListView. */
+    Object.defineProperty(module.exports, 'ListView', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'ListView has been removed from React Native. ' +
           'See https://fb.me/nolistview for more information or use ' +
           '`deprecated-react-native-listview`.',
-      );
-    },
-  });
+        );
+      },
+    });
 
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access SwipeableListView. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access SwipeableListView. */
-  Object.defineProperty(module.exports, 'SwipeableListView', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'SwipeableListView has been removed from React Native. ' +
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access SwipeableListView. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access SwipeableListView. */
+    Object.defineProperty(module.exports, 'SwipeableListView', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'SwipeableListView has been removed from React Native. ' +
           'See https://fb.me/nolistview for more information or use ' +
           '`deprecated-react-native-swipeable-listview`.',
-      );
-    },
-  });
+        );
+      },
+    });
 
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access WebView. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access WebView. */
-  Object.defineProperty(module.exports, 'WebView', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'WebView has been removed from React Native. ' +
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access WebView. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access WebView. */
+    Object.defineProperty(module.exports, 'WebView', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'WebView has been removed from React Native. ' +
           "It can now be installed and imported from 'react-native-webview' instead of 'react-native'. " +
           'See https://github.com/react-native-webview/react-native-webview',
-      );
-    },
-  });
+        );
+      },
+    });
 
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access NetInfo. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access NetInfo. */
-  Object.defineProperty(module.exports, 'NetInfo', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'NetInfo has been removed from React Native. ' +
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access NetInfo. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access NetInfo. */
+    Object.defineProperty(module.exports, 'NetInfo', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'NetInfo has been removed from React Native. ' +
           "It can now be installed and imported from '@react-native-community/netinfo' instead of 'react-native'. " +
           'See https://github.com/react-native-netinfo/react-native-netinfo',
-      );
-    },
-  });
+        );
+      },
+    });
 
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access CameraRoll. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access CameraRoll. */
-  Object.defineProperty(module.exports, 'CameraRoll', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'CameraRoll has been removed from React Native. ' +
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access CameraRoll. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access CameraRoll. */
+    Object.defineProperty(module.exports, 'CameraRoll', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'CameraRoll has been removed from React Native. ' +
           "It can now be installed and imported from '@react-native-community/cameraroll' instead of 'react-native'. " +
           'See https://github.com/react-native-cameraroll/react-native-cameraroll',
-      );
-    },
-  });
+        );
+      },
+    });
 
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access ImageStore. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access ImageStore. */
-  Object.defineProperty(module.exports, 'ImageStore', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'ImageStore has been removed from React Native. ' +
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access ImageStore. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access ImageStore. */
+    Object.defineProperty(module.exports, 'ImageStore', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'ImageStore has been removed from React Native. ' +
           'To get a base64-encoded string from a local image use either of the following third-party libraries:' +
           "* expo-file-system: `readAsStringAsync(filepath, 'base64')`" +
           "* react-native-fs: `readFile(filepath, 'base64')`",
-      );
-    },
-  });
+        );
+      },
+    });
 
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access ImageEditor. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access ImageEditor. */
-  Object.defineProperty(module.exports, 'ImageEditor', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'ImageEditor has been removed from React Native. ' +
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access ImageEditor. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access ImageEditor. */
+    Object.defineProperty(module.exports, 'ImageEditor', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'ImageEditor has been removed from React Native. ' +
           "It can now be installed and imported from '@react-native-community/image-editor' instead of 'react-native'. " +
           'See https://github.com/callstack/react-native-image-editor',
-      );
-    },
-  });
+        );
+      },
+    });
 
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access TimePickerAndroid. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access TimePickerAndroid. */
-  Object.defineProperty(module.exports, 'TimePickerAndroid', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'TimePickerAndroid has been removed from React Native. ' +
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access TimePickerAndroid. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access TimePickerAndroid. */
+    Object.defineProperty(module.exports, 'TimePickerAndroid', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'TimePickerAndroid has been removed from React Native. ' +
           "It can now be installed and imported from '@react-native-community/datetimepicker' instead of 'react-native'. " +
           'See https://github.com/react-native-datetimepicker/datetimepicker',
-      );
-    },
-  });
+        );
+      },
+    });
 
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access ToolbarAndroid. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access ToolbarAndroid. */
-  Object.defineProperty(module.exports, 'ToolbarAndroid', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'ToolbarAndroid has been removed from React Native. ' +
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access ToolbarAndroid. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access ToolbarAndroid. */
+    Object.defineProperty(module.exports, 'ToolbarAndroid', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'ToolbarAndroid has been removed from React Native. ' +
           "It can now be installed and imported from '@react-native-community/toolbar-android' instead of 'react-native'. " +
           'See https://github.com/react-native-toolbar-android/toolbar-android',
-      );
-    },
-  });
+        );
+      },
+    });
 
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access ViewPagerAndroid. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access ViewPagerAndroid. */
-  Object.defineProperty(module.exports, 'ViewPagerAndroid', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'ViewPagerAndroid has been removed from React Native. ' +
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access ViewPagerAndroid. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access ViewPagerAndroid. */
+    Object.defineProperty(module.exports, 'ViewPagerAndroid', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'ViewPagerAndroid has been removed from React Native. ' +
           "It can now be installed and imported from 'react-native-pager-view' instead of 'react-native'. " +
           'See https://github.com/callstack/react-native-pager-view',
-      );
-    },
-  });
+        );
+      },
+    });
 
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access CheckBox. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access CheckBox. */
-  Object.defineProperty(module.exports, 'CheckBox', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'CheckBox has been removed from React Native. ' +
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access CheckBox. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access CheckBox. */
+    Object.defineProperty(module.exports, 'CheckBox', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'CheckBox has been removed from React Native. ' +
           "It can now be installed and imported from '@react-native-community/checkbox' instead of 'react-native'. " +
           'See https://github.com/react-native-checkbox/react-native-checkbox',
-      );
-    },
-  });
+        );
+      },
+    });
 
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access SegmentedControlIOS. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access SegmentedControlIOS. */
-  Object.defineProperty(module.exports, 'SegmentedControlIOS', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'SegmentedControlIOS has been removed from React Native. ' +
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access SegmentedControlIOS. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access SegmentedControlIOS. */
+    Object.defineProperty(module.exports, 'SegmentedControlIOS', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'SegmentedControlIOS has been removed from React Native. ' +
           "It can now be installed and imported from '@react-native-community/segmented-checkbox' instead of 'react-native'." +
           'See https://github.com/react-native-segmented-control/segmented-control',
-      );
-    },
-  });
+        );
+      },
+    });
 
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access StatusBarIOS. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access StatusBarIOS. */
-  Object.defineProperty(module.exports, 'StatusBarIOS', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'StatusBarIOS has been removed from React Native. ' +
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access StatusBarIOS. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access StatusBarIOS. */
+    Object.defineProperty(module.exports, 'StatusBarIOS', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'StatusBarIOS has been removed from React Native. ' +
           'Has been merged with StatusBar. ' +
           'See https://reactnative.dev/docs/statusbar',
-      );
-    },
-  });
+        );
+      },
+    });
 
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access PickerIOS. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access PickerIOS. */
-  Object.defineProperty(module.exports, 'PickerIOS', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'PickerIOS has been removed from React Native. ' +
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access PickerIOS. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access PickerIOS. */
+    Object.defineProperty(module.exports, 'PickerIOS', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'PickerIOS has been removed from React Native. ' +
           "It can now be installed and imported from '@react-native-picker/picker' instead of 'react-native'. " +
           'See https://github.com/react-native-picker/picker',
-      );
-    },
-  });
+        );
+      },
+    });
 
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access Picker. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access Picker. */
-  Object.defineProperty(module.exports, 'Picker', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'Picker has been removed from React Native. ' +
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access Picker. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access Picker. */
+    Object.defineProperty(module.exports, 'Picker', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'Picker has been removed from React Native. ' +
           "It can now be installed and imported from '@react-native-picker/picker' instead of 'react-native'. " +
           'See https://github.com/react-native-picker/picker',
-      );
-    },
-  });
-  /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
-   * attempting to access DatePickerAndroid. */
-  /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
-   * attempting to access DatePickerAndroid. */
-  Object.defineProperty(module.exports, 'DatePickerAndroid', {
-    configurable: true,
-    get() {
-      invariant(
-        false,
-        'DatePickerAndroid has been removed from React Native. ' +
+        );
+      },
+    });
+    /* $FlowFixMe[prop-missing] This is intentional: Flow will error when
+     * attempting to access DatePickerAndroid. */
+    /* $FlowFixMe[invalid-export] This is intentional: Flow will error when
+     * attempting to access DatePickerAndroid. */
+    Object.defineProperty(module.exports, 'DatePickerAndroid', {
+      configurable: true,
+      get() {
+        invariant(
+          false,
+          'DatePickerAndroid has been removed from React Native. ' +
           "It can now be installed and imported from '@react-native-community/datetimepicker' instead of 'react-native'. " +
           'See https://github.com/react-native-datetimepicker/datetimepicker',
-      );
-    },
-  });
-}
+        );
+      },
+    });
+  }
diff --git a/node_modules/react-native/scripts/.packager.bat b/node_modules/react-native/scripts/.packager.bat
new file mode 100644
index 0000000..e89260e
--- /dev/null
+++ b/node_modules/react-native/scripts/.packager.bat
@@ -0,0 +1 @@
+set RCT_METRO_PORT=8081
\ No newline at end of file
